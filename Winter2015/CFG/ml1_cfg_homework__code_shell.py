##################################################################################  MLEARN 210 : homework #5  ::  Context Free Grammar (CFG)#################################################################################################################################################################################################################################################import string##################################################################################  GLOBAL DATA### Production Rules of our simplified Context-Free Grammar.##     S -> NP VP                                                  # complete sentence#     PP -> P NP                                                   # prepositional phrase#     NP -> N | Det N | NP PP                               # noun phrase  (may include zero or more preposition phrases)  ;;  [ COMPLETE THIS CODE ]  add rules to include ADJECTIVES (see below)#     VP -> V | V NP | VP PP                                # verb phrase  (may include an adverb and/or zero or more prepositonal phrases) ;;  [ COMPLETE THIS CODE ]  add rules to include an ADVERB (see below)##     ADJS -> ???  [ TODO COMPLETE THIS CODE ]                                 # one or more adjectives##g_PRODUCTION_RULES = {    "S" :     [ "NP VP" ],    "PP" :  ["P NP" ],    #    #  [ COMPLETE THIS CODE ]  -- Add more terms to the right side of this set of production rules, to allow for ADJECTIVES;    #                                              (matching e.g. "yellow dog" or "the big brown dog")    #    "NP" : [ "N", "Det N", "NP PP" , "ADJS NP", "Det NP" ],    #    #  [ COMPLETE THIS CODE ]  -- Add more terms to the right side of this set of production rules, to allow for a signle ADVERB;    #                                              (matching e.g. "walks quickly" or "walks the dog quickly" or "walks with the dog quickly")    #        "VP" : [ "V", "V NP", "VP PP", "VP ADV" ],    #    #  [ TODO COMPLETE THIS CODE ]  -- Add the correct right-side production rules to match one or more ADJECTIVES.    #    "ADJS" : [ "ADJ" , "ADJ ADJ"],  }## Since we don't recursively try all parsings, and use a simplified grammar, we prioritize the application of the above rules; this fixes a few cases.# (For example, we don't want a Noun (N) collapsed to a Noun Phrase (NP) before all Adjectives (ADJ) are collapsed to ADJS).#g_PRODUCTION_RULES_PRIORITY = [ "ADJS", "NP", "PP", "VP", "S" ]## This identifies the "root" of the Context-Free Grammar, which is the goal state : a proper SENTENCE (S).# (This is often identified by being listed as the first rule).#g_GOAL_SYMBOL = "S"## Vocabulary, represented as more production rules.# Matches each word in the vocabulary to its part-of-speech (Noun, Verb, Preposition, Determiner, Adjective, Adverb).## Note: for this exercise, we don't have words with multiple parts of speech (like "fish", which can be Noun or Verb).#g_VOCAB = {    "N" : [ "I", "me", "you", "he", "she", "it", "we", "us", "they", "them", "boy", "girl", "guy", "man", "woman", "boys", "girls", "men", "women", "person", "people",              "myself", "yourself", "himself", "herself", "ourselves", "yourselves", "themselves", "itself",              "car", "house", "home", "store", "park", "town",              "groceries", "thing", "things",              "dog", "dogs", "cat", "cats"            ],    "V" : [ "go", "goes", "walk", "walks", "walked", "went", "drive", "drove",              "shop", "shopped", "buy", "bought",              "sit", "sat", "am", "are", "is",              "like", "dislike", "love", "hate"            ],    "P" : [ "to", "from", "over", "under", "at", "upon", "in", "with", "within", "inside", "out", "outside", "before", "after", "during", "by" ],    "Det" : [ "the", "a", "an" ],    "ADJ" : [ "big", "large", "small", "fast", "rapid", "slow", "cheap", "expensive",                  "white", "black", "red", "blue", "green", "brown", "yellow",                  "rich", "poor", "nice", "quiet", "noisy"               ],    "ADV" : [ "quickly", "slowly", "nicely", "softly", "quietly", "loudly" ],      }################################################################################################################################################################################################################################################## ProcessInputSentence#def ProcessInputSentence(words_list):  print("\r\n   -> ProcessInputSentence :  %s ... \r\n" % str(words_list))  #  # Replace any vocabulary words with their symbols.  #  found_all_words = True  for i in range(0, len(words_list)):    word = words_list[i].lower()    found_word = False    for part_of_speech in g_VOCAB:      for vocab_word in g_VOCAB[part_of_speech]:        if vocab_word.lower() == word:          words_list[i] = part_of_speech    # replace word with its symbol          found_word = True          break    if not found_word:      print(" ERROR: the word '%s' is not in the vocabulary.  You can add it to g_VOCAB[] in the code if you like." % word)      found_all_words = False      break  if not found_all_words:    parsed_ok = False  else:    #    # Loop for as long as we make progress by reducing the sentence.    #    making_progress = True    while making_progress:      making_progress = False        print("   -> processing : %s ... \r\n" % str(words_list))      #      # Attempt to apply production rules for each left-side symbol, in priority order.      #      for left_symbol in g_PRODUCTION_RULES_PRIORITY:                   # for each left-side symbol of the production rules (e.g. "PP")        #        # These will keep track of the longest matched rule.        #        longest_match_left_symbol = ""      # will get the left-side symbol for the longest matched production rule        longest_match_right = []               # will get the list of right-side symbols for the longest matched production rule        longest_match_pos = -1                # will get the position in words_list[] of the longest matched production rule              for right_side_str in g_PRODUCTION_RULES[left_symbol]:            # take each right-side string of symbols (e.g. "P NP")          right_side_list = right_side_str.split(' ') if right_side_str else []     # convert e.g. "P NP" to the list [ "P", "NP" ]          # print("          (trying rule: %s  ->  %s ...)" % (left_symbol, right_side_list))          #          # Does this RIGHT-SIDE of the current rule match any position in words_list[] ???          #          right_side_matches = False          for wi in range(0, len(words_list)):            right_side_matches = True            for ri in range(0, len(right_side_list)):              if (wi+ri >= len(words_list)) or (words_list[wi+ri] != right_side_list[ri]):                right_side_matches = False                break                            if right_side_matches:              #              # We found a match.  Is it the longest-matched rule so far ?              #              if len(right_side_list) > len(longest_match_right) :                print("          (matched rule: %s  ->  %s ... )" % (left_symbol, right_side_list))                longest_match_left_symbol = left_symbol                longest_match_right = right_side_list                longest_match_pos = wi        #        # Did ANY production rules match for this LEFT-SIDE symbol?  If so, do the substitution, and continue.        #        if longest_match_pos >= 0:          print("          (applying rule: %s  ->  %s ... ) \r\n" % (longest_match_left_symbol, longest_match_right))          end_pos = longest_match_pos + len(longest_match_right) - 1          words_list[longest_match_pos : end_pos+1] = [ longest_match_left_symbol ]    # SUBSTITUTE the LEFT-SIDE symbol for the matched RIGHT-SIDE symbols list in words_list[]    ***          making_progress = True          break                #    # Parsing succeeded iff the sentence was reduced to the target symbol ('S', for a complete sentence).    #    parsed_ok = ((len(words_list) == 1) and (words_list[0] == g_GOAL_SYMBOL))  return parsed_ok################################################################################################################################################################  ################################################################################## RunQueryLoop#def RunQueryLoop():  #  #  #  while True:    #    # Query the user for EVIDENCE input ...    #    print("\r\n ENTER an English sentence (using the limited vocabulary in g_VOCAB[] ) ... ")    #    # Clean up user response, remove punctuation, and convert to lower case.    #    try:      response = raw_input(" >> ").lower().strip()      response = response.translate(string.maketrans("",""), string.punctuation)   # remove all punctuation    except Exception as e:      # user probably hit Control+C ; exit gracefully below      response = "exit"    if response == "":      # ignore empty response      pass    elif response in [ "exit", "quit" ]:      break    else:      words_list = response.split(' ')      words_list = filter(lambda word : (len(word) > 0), words_list)  # remove any empty words in list (resulting from multiple spaces, before we did the split() )      if len(words_list) == 0:        # ignore empty response        pass      else:        parsed_ok = ProcessInputSentence(words_list)        if parsed_ok:          print("\r\n (parsed ok)\r\n")        else:          print("\r\n parsing FAILED\r\n")    ################################################################################################################################################################  ################################################################################## This is the main() entrypoint of every top-level Python program. #if __name__ == '__main__':  RunQueryLoop()########################################################################################################################################################